name: CI - Build and Test v2.0

on:
  push:
    branches: [ v2-dev, feature/epic* ]
    paths:
      - 'src/**'
      - 'tests/**'
      - '.github/workflows/**'
      - '*.csproj'
      - '*.sln'
      - 'Directory.Build.props'
      - 'Directory.Packages.props'
  pull_request:
    branches: [ v2-dev, main ]
    paths:
      - 'src/**'
      - 'tests/**'
      - '.github/workflows/**'
      - '*.csproj'
      - '*.sln'
      - 'Directory.Build.props'
      - 'Directory.Packages.props'
     
env:
  # .NET Configuration
  DOTNET_VERSION: '9.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  
  # Project Paths
  SOLUTION_PATH: 'ClipboardToFile.sln'
  PROJECT_PATH: 'src/ClipboardToFile.csproj'
  TEST_PROJECT_PATH: 'tests/tests.csproj'
  
  # Build Configuration
  BUILD_CONFIGURATION: 'Debug'
  TARGET_PLATFORM: 'x64'

jobs:
  build-and-test:
    name: Build and Test
    runs-on: windows-latest
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Required for GitVersion and blame analysis

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # Enhanced NuGet caching with fallback keys
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.nuget/v3-cache
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          ${{ runner.os }}-nuget-

    # Cache build outputs for potential reuse
    - name: Cache build outputs
      uses: actions/cache@v4
      with:
        path: |
          src/bin
          src/obj
          tests/bin
          tests/obj
        key: ${{ runner.os }}-build-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-build-

    - name: Restore main project dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal

    - name: Restore test project dependencies
      run: dotnet restore ${{ env.TEST_PROJECT_PATH }} --verbosity minimal

    - name: Build application
      run: |
        dotnet build ${{ env.PROJECT_PATH }} \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-restore \
          --verbosity normal \
          /p:Platform=${{ env.TARGET_PLATFORM }} \
          /p:TreatWarningsAsErrors=false \
          /p:ContinuousIntegrationBuild=true

    - name: Build tests
      run: |
        dotnet build ${{ env.TEST_PROJECT_PATH }} \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-restore \
          --verbosity normal

    - name: Run unit tests with coverage
      run: |
        dotnet test ${{ env.TEST_PROJECT_PATH }} \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger trx \
          --logger "console;verbosity=detailed" \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover

    - name: Upload test results
      if: always()  # Upload even if tests fail
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ env.TARGET_PLATFORM }}
        path: ./TestResults
        retention-days: 7

    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v4
      with:
        directory: ./TestResults
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false  # Don't fail CI if codecov upload fails

  code-quality:
    name: Code Quality Analysis
    runs-on: windows-latest
    # Run in parallel with build-and-test for faster feedback
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Required for blame analysis

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # Reuse the same cache as build job
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.nuget/v3-cache
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: |
        dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal
        dotnet restore ${{ env.TEST_PROJECT_PATH }} --verbosity minimal

    # Enhanced code analysis with stricter settings
    - name: Run code analysis
      run: |
        dotnet build ${{ env.PROJECT_PATH }} \
          --configuration Release \
          --verbosity normal \
          /p:TreatWarningsAsErrors=true \
          /p:WarningsAsErrors="" \
          /p:WarningsNotAsErrors="CS1591;CS1573" \
          /p:RunAnalyzersDuringBuild=true \
          /p:EnableNETAnalyzers=true \
          /p:AnalysisLevel=latest

    # Check code formatting (fail if not formatted)
    - name: Check formatting
      run: |
        dotnet format ${{ env.PROJECT_PATH }} --verify-no-changes --verbosity diagnostic
        dotnet format ${{ env.TEST_PROJECT_PATH }} --verify-no-changes --verbosity diagnostic

    # Additional static analysis tools
    - name: Run security analysis
      run: |
        # Install security analyzer if not already present
        dotnet list ${{ env.PROJECT_PATH }} package | grep -q Microsoft.CodeAnalysis.NetAnalyzers || \
          dotnet add ${{ env.PROJECT_PATH }} package Microsoft.CodeAnalysis.NetAnalyzers --version 8.0.0
        
        # Run analysis
        dotnet build ${{ env.PROJECT_PATH }} \
          --configuration Release \
          --verbosity normal \
          /p:RunCodeAnalysis=true \
          /p:CodeAnalysisRuleSet=security.ruleset || true

  security-scan:
    name: Security Vulnerability Scan
    runs-on: windows-latest
    # Run in parallel with other jobs for faster feedback
    if: github.event_name == 'pull_request'
    
    permissions:
      # Required for uploading SARIF results to GitHub Security tab
      security-events: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # Reuse the same cache
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.nuget/v3-cache
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: |
        dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal
        dotnet restore ${{ env.TEST_PROJECT_PATH }} --verbosity minimal

    # Enhanced vulnerability scanning with failure conditions
    - name: Scan for vulnerable packages
      id: vulnerability_scan
      run: |
        echo "ğŸ” Scanning for vulnerable packages..."
        
        # Scan main project
        echo "Scanning main project..."
        dotnet list ${{ env.PROJECT_PATH }} package --vulnerable --include-transitive > vulnerable-packages-main.log 2>&1
        MAIN_VULNERABILITIES=$?
        
        # Scan test project  
        echo "Scanning test project..."
        dotnet list ${{ env.TEST_PROJECT_PATH }} package --vulnerable --include-transitive > vulnerable-packages-tests.log 2>&1
        TEST_VULNERABILITIES=$?
        
        # Check for critical/high vulnerabilities
        CRITICAL_FOUND=0
        if grep -i "critical\|high" vulnerable-packages-main.log vulnerable-packages-tests.log; then
          echo "âŒ Critical or High severity vulnerabilities found!"
          CRITICAL_FOUND=1
        fi
        
        # Output results
        echo "main_exit_code=$MAIN_VULNERABILITIES" >> $GITHUB_OUTPUT
        echo "test_exit_code=$TEST_VULNERABILITIES" >> $GITHUB_OUTPUT
        echo "critical_found=$CRITICAL_FOUND" >> $GITHUB_OUTPUT
        
        # Display scan results
        echo "=== Main Project Vulnerabilities ==="
        cat vulnerable-packages-main.log
        echo "=== Test Project Vulnerabilities ==="
        cat vulnerable-packages-tests.log

    # Install and run additional security scanners
    - name: Install DevSkim CLI
      run: |
        dotnet tool install --global Microsoft.CST.DevSkim.CLI

    - name: Run DevSkim security analysis
      run: |
        echo "ğŸ›¡ï¸ Running DevSkim security analysis..."
        devskim analyze src/ --output-format sarif --output-file devskim-results.sarif || true
        
        # Also run on tests for completeness
        devskim analyze tests/ --output-format sarif --output-file devskim-tests-results.sarif || true

    # Upload SARIF results to GitHub Security tab
    - name: Upload DevSkim SARIF results
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: |
          devskim-results.sarif
          devskim-tests-results.sarif
        category: "DevSkim"

    # Create security summary
    - name: Generate security summary
      if: always()
      run: |
        echo "# ğŸ›¡ï¸ Security Scan Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.vulnerability_scan.outputs.critical_found }}" = "1" ]; then
          echo "## âŒ Critical Issues Found" >> $GITHUB_STEP_SUMMARY
          echo "Critical or High severity vulnerabilities detected in dependencies." >> $GITHUB_STEP_SUMMARY
        else
          echo "## âœ… No Critical Issues" >> $GITHUB_STEP_SUMMARY
          echo "No critical or high severity vulnerabilities found." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Package Vulnerability Scan Results" >> $GITHUB_STEP_SUMMARY
        echo "- Main project exit code: ${{ steps.vulnerability_scan.outputs.main_exit_code }}" >> $GITHUB_STEP_SUMMARY
        echo "- Test project exit code: ${{ steps.vulnerability_scan.outputs.test_exit_code }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ“‹ Detailed results available in job artifacts and GitHub Security tab." >> $GITHUB_STEP_SUMMARY

    - name: Upload security scan results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-scan-results
        path: |
          vulnerable-packages-main.log
          vulnerable-packages-tests.log
          devskim-results.sarif
          devskim-tests-results.sarif
        retention-days: 30

    # Fail the job if critical vulnerabilities are found
    - name: Fail on critical vulnerabilities
      if: steps.vulnerability_scan.outputs.critical_found == '1'
      run: |
        echo "ğŸ’¥ Build failed due to critical/high severity vulnerabilities!"
        echo "Please review the security scan results and update vulnerable packages."
        exit 1

  epic-progress-check:
    name: Epic Progress Tracking
    runs-on: ubuntu-latest
    # Only run for epic feature branches
    if: startsWith(github.ref, 'refs/heads/feature/epic')

    steps:
    - name: Extract Epic Number
      id: epic
      run: |
        BRANCH_NAME="${{ github.ref_name }}"
        EPIC_NUM=$(echo $BRANCH_NAME | grep -o 'epic[0-9]\+' | grep -o '[0-9]\+')
        echo "number=$EPIC_NUM" >> $GITHUB_OUTPUT
        echo "Extracted epic number: $EPIC_NUM"

    - name: Post Epic Progress Update
      uses: actions/github-script@v7
      with:
        script: |
          const epicNumber = '${{ steps.epic.outputs.number }}';
          
          try {
            // Find Epic issue by label and title pattern
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'ğŸ—ï¸ epic',
              state: 'open'
            });
            
            const epicIssue = issues.data.find(issue => 
              issue.title.includes(`Epic ${epicNumber}`) || 
              issue.title.includes(`Epic #${epicNumber}`) ||
              issue.title.toLowerCase().includes(`epic ${epicNumber}`)
            );
            
            if (epicIssue) {
              const buildStatus = '${{ needs.build-and-test.result }}' === 'success' ? 'âœ…' : 'âŒ';
              const statusText = '${{ needs.build-and-test.result }}' === 'success' ? 'passing' : 'failing';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicIssue.number,
                body: `ğŸš€ **CI Build Update for Epic ${epicNumber}**\n\n` +
                      `${buildStatus} **Status**: Build and tests ${statusText}\n` +
                      `ğŸ“ **Branch**: \`${{ github.ref_name }}\`\n` +
                      `ğŸ”— **Commit**: ${{ github.sha }}\n` +
                      `ğŸ“Š **Platform**: ${{ env.TARGET_PLATFORM }} ${{ env.BUILD_CONFIGURATION }}\n\n` +
                      `[View full CI run â†’](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
              
              console.log(`âœ… Updated Epic #${epicIssue.number}`);
            } else {
              console.log(`âš ï¸ No Epic issue found for Epic ${epicNumber}`);
            }
          } catch (error) {
            console.log(`âŒ Error updating Epic: ${error.message}`);
          }

  validate-epic-completion:
    name: Epic Completion Validation
    runs-on: ubuntu-latest
    # Only run for PRs targeting v2-dev from epic branches
    if: github.event_name == 'pull_request' && github.base_ref == 'v2-dev' && startsWith(github.head_ref, 'feature/epic')

    steps:
    - name: Validate Epic Completion Checklist
      uses: actions/github-script@v7
      with:
        script: |
          const pr = context.payload.pull_request;
          const body = pr.body || '';
          const headRef = pr.head.ref;
          
          console.log(`Validating Epic completion for PR #${pr.number}`);
          console.log(`Branch: ${headRef}`);
          
          // Extract epic number from branch name
          const epicMatch = headRef.match(/epic(\d+)/);
          const epicNumber = epicMatch ? epicMatch[1] : 'unknown';
          
          // Define required checklist items for Epic completion
          const requiredChecks = [
            'All acceptance criteria met',
            'Unit tests written and passing', 
            'Integration tests completed',
            'Code reviewed and approved',
            'Documentation updated',
            'Epic tracking issue updated'
          ];
          
          // Check which items are missing from the PR body
          const missingChecks = requiredChecks.filter(check => {
            const patterns = [
              `- [x] ${check}`,
              `- [X] ${check}`,
              `* [x] ${check}`,
              `* [X] ${check}`
            ];
            return !patterns.some(pattern => body.includes(pattern));
          });
          
          // Generate validation results
          if (missingChecks.length > 0) {
            const warningMessage = `âš ï¸ **Epic ${epicNumber} Completion Checklist Validation**\n\n` +
              `This PR appears to be completing an Epic, but some required items are missing from the description:\n\n` +
              missingChecks.map(item => `- [ ] ${item}`).join('\n') + '\n\n' +
              `**Please ensure all Epic requirements are completed before merging.**\n\n` +
              `### How to fix this:\n` +
              `1. Edit this PR description\n` +
              `2. Add the missing checklist items\n` +
              `3. Mark completed items as \`- [x] Item description\`\n\n` +
              `### Required Epic completion checklist:\n` +
              requiredChecks.map(item => `- [ ] ${item}`).join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: warningMessage
            });
            
            console.log(`âŒ Missing ${missingChecks.length} required items`);
            core.setFailed(`Epic completion validation failed: ${missingChecks.length} missing items`);
          } else {
            const successMessage = `âœ… **Epic ${epicNumber} Completion Validated**\n\n` +
              `All required Epic completion items are present in the PR description. ` +
              `The Epic appears ready for final review and merge!`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: successMessage
            });
            
            console.log(`âœ… All Epic completion requirements satisfied`);
          }

  notify-status:
    name: Notify Build Status
    runs-on: ubuntu-latest
    needs: [build-and-test]
    # Include security scan only if it ran (PR events)
    if: always()

    steps:
    - name: Determine overall status
      id: status
      run: |
        BUILD_STATUS="${{ needs.build-and-test.result }}"
        
        # Check if security scan ran and its status
        SECURITY_STATUS="skipped"
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          SECURITY_STATUS="${{ needs.security-scan.result || 'not_run' }}"
        fi
        
        echo "build_status=$BUILD_STATUS" >> $GITHUB_OUTPUT
        echo "security_status=$SECURITY_STATUS" >> $GITHUB_OUTPUT
        
        # Determine overall success
        if [ "$BUILD_STATUS" = "success" ] && [ "$SECURITY_STATUS" != "failure" ]; then
          echo "overall_status=success" >> $GITHUB_OUTPUT
        else
          echo "overall_status=failure" >> $GITHUB_OUTPUT
        fi

    - name: Build Success Notification
      if: steps.status.outputs.overall_status == 'success'
      run: |
        echo "âœ… All checks passed successfully!"
        echo "ğŸ—ï¸ Build: ${{ steps.status.outputs.build_status }}"
        echo "ğŸ›¡ï¸ Security: ${{ steps.status.outputs.security_status }}"
        echo "ğŸ¯ Target: ${{ env.TARGET_PLATFORM }} ${{ env.BUILD_CONFIGURATION }}"
        echo "ğŸ”§ .NET: ${{ env.DOTNET_VERSION }}"

    - name: Build Failure Notification  
      if: steps.status.outputs.overall_status == 'failure'
      run: |
        echo "âŒ One or more checks failed!"
        echo "ğŸ—ï¸ Build: ${{ steps.status.outputs.build_status }}"
        echo "ğŸ›¡ï¸ Security: ${{ steps.status.outputs.security_status }}"
        echo "ğŸ“‹ Check the job logs for detailed error information"
        exit 1

    - name: Update commit status
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const state = '${{ steps.status.outputs.overall_status }}' === 'success' ? 'success' : 'failure';
          const description = state === 'success' ? 
            'All builds and tests passed' : 
            'Build or tests failed';
            
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: context.sha,
            state: state,
            description: description,
            context: 'ci/build-and-test'
          });