name: CI - Build and Test v2.0

on:
  push:
    branches: [ v2-dev, feature/epic* ]
    paths:
      - 'src/**'
      - 'tests/**'
      - '.github/workflows/**'
      - '*.csproj'
      - '*.sln'
      - 'Directory.Build.props'
      - 'Directory.Packages.props'
  pull_request:
    branches: [ v2-dev, main ]
    paths:
      - 'src/**'
      - 'tests/**'
      - '.github/workflows/**'
      - '*.csproj'
      - '*.sln'
      - 'Directory.Build.props'
      - 'Directory.Packages.props'

env:
  # .NET Configuration
  DOTNET_VERSION: '9.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  
  # Project Paths
  SOLUTION_PATH: 'ClipboardToFile.sln'
  PROJECT_PATH: 'src/ClipboardToFile.csproj'
  TEST_PROJECT_PATH: 'tests/tests.csproj'
  
  # Build Configuration
  BUILD_CONFIGURATION: 'Debug'
  TARGET_PLATFORM: 'x64'

jobs:
  build-and-test:
    name: Build and Test
    runs-on: windows-latest
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Required for GitVersion and blame analysis

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # Enhanced NuGet caching with fallback keys
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.nuget/v3-cache
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          ${{ runner.os }}-nuget-

    # Cache build outputs for potential reuse
    - name: Cache build outputs
      uses: actions/cache@v4
      with:
        path: |
          src/bin
          src/obj
          tests/bin
          tests/obj
        key: ${{ runner.os }}-build-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-build-

    - name: Restore main project dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal

    - name: Restore test project dependencies
      run: dotnet restore ${{ env.TEST_PROJECT_PATH }} --verbosity minimal

    - name: Build application
      run: |
        dotnet build ${{ env.PROJECT_PATH }} `
          --configuration ${{ env.BUILD_CONFIGURATION }} `
          --no-restore `
          --verbosity normal `
          /p:Platform=${{ env.TARGET_PLATFORM }} `
          /p:TreatWarningsAsErrors=false `
          /p:ContinuousIntegrationBuild=true

    - name: Build tests
      run: |
        dotnet build ${{ env.TEST_PROJECT_PATH }} `
          --configuration ${{ env.BUILD_CONFIGURATION }} `
          --no-restore `
          --verbosity normal

    - name: Run unit tests with coverage
      run: |
        # Create simple runsettings for coverage if it doesn't exist
        if (-not (Test-Path "coverlet.runsettings")) {
          Write-Host "Creating coverlet.runsettings file..."
          
          # Create XML content as string
          $xmlContent = '<?xml version="1.0" encoding="utf-8" ?>'
          $xmlContent += "`n<RunSettings>"
          $xmlContent += "`n  <DataCollectionRunSettings>"
          $xmlContent += "`n    <DataCollectors>"
          $xmlContent += "`n      <DataCollector friendlyName=`"XPlat code coverage`">"
          $xmlContent += "`n        <Configuration>"
          $xmlContent += "`n          <Format>cobertura,opencover</Format>"
          $xmlContent += "`n          <Exclude>[*Tests*]*,[*Test*]*</Exclude>"
          $xmlContent += "`n        </Configuration>"
          $xmlContent += "`n      </DataCollector>"
          $xmlContent += "`n    </DataCollectors>"
          $xmlContent += "`n  </DataCollectionRunSettings>"
          $xmlContent += "`n</RunSettings>"
          
          $xmlContent | Out-File -FilePath "coverlet.runsettings" -Encoding UTF8
        }
        
        dotnet test ${{ env.TEST_PROJECT_PATH }} `
          --configuration ${{ env.BUILD_CONFIGURATION }} `
          --no-build `
          --verbosity normal `
          --logger trx `
          --logger "console;verbosity=detailed" `
          --collect:"XPlat Code Coverage" `
          --results-directory ./TestResults `
          --settings coverlet.runsettings
          
        # List generated files for debugging
        Write-Host "=== Generated Test Files ==="
        Get-ChildItem -Path ./TestResults -Recurse | ForEach-Object { Write-Host $_.FullName }

    - name: Upload test results
      if: always()  # Upload even if tests fail
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ env.TARGET_PLATFORM }}
        path: ./TestResults
        retention-days: 7

    # Generate coverage report for manual review
    - name: Generate coverage summary
      if: always()
      run: |
        Write-Host "üìä Test Coverage Summary"
        Write-Host "========================"
        
        # Look for coverage files
        $coverageFiles = Get-ChildItem -Path ./TestResults -Filter "*.xml" -Recurse
        if ($coverageFiles.Count -gt 0) {
          Write-Host "‚úÖ Found $($coverageFiles.Count) coverage file(s):"
          $coverageFiles | ForEach-Object { Write-Host "  - $($_.Name)" }
          
          # Add to job summary
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## üìä Test Coverage"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "Coverage reports generated and available in artifacts."
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value ""
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "### Coverage Files"
          $coverageFiles | ForEach-Object { 
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- ``$($_.Name)``"
          }
        } else {
          Write-Host "‚ö†Ô∏è No coverage files found"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## ‚ö†Ô∏è Test Coverage"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "No coverage files were generated. Check test configuration."
        }

    # Upload coverage to Codecov (with GitHub integration)
    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v4
      with:
        directory: ./TestResults
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false  # Don't fail CI if codecov upload fails
        verbose: true  # Enable verbose logging for debugging
        files: './TestResults/**/coverage.cobertura.xml,./TestResults/**/coverage.opencover.xml'
        override_branch: ${{ github.head_ref || github.ref_name }}
        override_commit: ${{ github.sha }}
        override_pr: ${{ github.event.number }}
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN || '' }}

  code-quality:
    name: Code Quality Analysis
    runs-on: windows-latest
    # Run in parallel with build-and-test for faster feedback
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Required for blame analysis

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # Reuse the same cache as build job
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.nuget/v3-cache
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: |
        dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal
        dotnet restore ${{ env.TEST_PROJECT_PATH }} --verbosity minimal

    # Enhanced code analysis with stricter settings
    - name: Run code analysis
      run: |
        dotnet build ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --verbosity normal `
          /p:TreatWarningsAsErrors=false `
          /p:RunAnalyzersDuringBuild=true `
          /p:EnableNETAnalyzers=true `
          /p:AnalysisLevel=latest
        
        Write-Host "‚úÖ Code analysis completed"

    # Check code formatting (fail if not formatted)
    - name: Check formatting
      run: |
        dotnet format ${{ env.PROJECT_PATH }} --verify-no-changes --verbosity diagnostic
        dotnet format ${{ env.TEST_PROJECT_PATH }} --verify-no-changes --verbosity diagnostic

    # Additional static analysis tools
    - name: Run security analysis
      run: |
        # Check if security analyzer is already present
        $packageList = dotnet list ${{ env.PROJECT_PATH }} package
        if (-not ($packageList | Select-String -Pattern "Microsoft.CodeAnalysis.NetAnalyzers" -Quiet)) {
          Write-Host "Installing Microsoft.CodeAnalysis.NetAnalyzers..."
          dotnet add ${{ env.PROJECT_PATH }} package Microsoft.CodeAnalysis.NetAnalyzers --version 8.0.0
        }
        
        # Run analysis
        dotnet build ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --verbosity normal `
          /p:RunCodeAnalysis=true `
          /p:CodeAnalysisRuleSet=security.ruleset
        
        if ($LASTEXITCODE -ne 0) { 
          Write-Host "Security analysis completed with warnings/errors"
        }

  security-scan:
    name: Security Vulnerability Scan
    runs-on: windows-latest
    # Run in parallel with other jobs for faster feedback
    if: github.event_name == 'pull_request'
    
    permissions:
      # Required for uploading SARIF results to GitHub Security tab
      security-events: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    # Reuse the same cache
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.nuget/v3-cache
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: |
        dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal
        dotnet restore ${{ env.TEST_PROJECT_PATH }} --verbosity minimal

    # Enhanced vulnerability scanning with failure conditions
    - name: Scan for vulnerable packages
      id: vulnerability_scan
      run: |
        Write-Host "üîç Scanning for vulnerable packages..."
        
        # Scan main project
        Write-Host "Scanning main project..."
        dotnet list ${{ env.PROJECT_PATH }} package --vulnerable --include-transitive > vulnerable-packages-main.log 2>&1
        $MAIN_VULNERABILITIES = $LASTEXITCODE
        
        # Scan test project  
        Write-Host "Scanning test project..."
        dotnet list ${{ env.TEST_PROJECT_PATH }} package --vulnerable --include-transitive > vulnerable-packages-tests.log 2>&1
        $TEST_VULNERABILITIES = $LASTEXITCODE
        
        # Check for critical/high vulnerabilities
        $CRITICAL_FOUND = 0
        if ((Get-Content vulnerable-packages-main.log, vulnerable-packages-tests.log | Select-String -Pattern "critical|high" -Quiet)) {
          Write-Host "‚ùå Critical or High severity vulnerabilities found!"
          $CRITICAL_FOUND = 1
        }
        
        # Output results for GitHub
        Add-Content -Path $env:GITHUB_OUTPUT -Value "main_exit_code=$MAIN_VULNERABILITIES"
        Add-Content -Path $env:GITHUB_OUTPUT -Value "test_exit_code=$TEST_VULNERABILITIES" 
        Add-Content -Path $env:GITHUB_OUTPUT -Value "critical_found=$CRITICAL_FOUND"
        
        # Display scan results
        Write-Host "=== Main Project Vulnerabilities ==="
        Get-Content vulnerable-packages-main.log
        Write-Host "=== Test Project Vulnerabilities ==="
        Get-Content vulnerable-packages-tests.log

    # Install and run additional security scanners
    - name: Install DevSkim CLI
      run: |
        dotnet tool install --global Microsoft.CST.DevSkim.CLI

    - name: Run DevSkim security analysis
      run: |
        Write-Host "üõ°Ô∏è Running DevSkim security analysis..."
        devskim analyze src/ --output-format sarif --output-file devskim-results.sarif
        if ($LASTEXITCODE -ne 0) { Write-Host "DevSkim analysis completed with warnings" }
        
        # Also run on tests for completeness
        devskim analyze tests/ --output-format sarif --output-file devskim-tests-results.sarif
        if ($LASTEXITCODE -ne 0) { Write-Host "DevSkim test analysis completed with warnings" }

    # Upload SARIF results to GitHub Security tab
    - name: Upload DevSkim SARIF results
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: |
          devskim-results.sarif
          devskim-tests-results.sarif
        category: "DevSkim"

    # Create security summary
    - name: Generate security summary
      if: always()
      run: |
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "# üõ°Ô∏è Security Scan Summary"
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value ""
        
        if ("${{ steps.vulnerability_scan.outputs.critical_found }}" -eq "1") {
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## ‚ùå Critical Issues Found"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "Critical or High severity vulnerabilities detected in dependencies."
        } else {
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## ‚úÖ No Critical Issues"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "No critical or high severity vulnerabilities found."
        }
        
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value ""
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "### Package Vulnerability Scan Results"
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- Main project exit code: ${{ steps.vulnerability_scan.outputs.main_exit_code }}"
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- Test project exit code: ${{ steps.vulnerability_scan.outputs.test_exit_code }}"
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value ""
        Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "üìã Detailed results available in job artifacts and GitHub Security tab."

    - name: Upload security scan results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-scan-results
        path: |
          vulnerable-packages-main.log
          vulnerable-packages-tests.log
          devskim-results.sarif
          devskim-tests-results.sarif
        retention-days: 30

    # Fail the job if critical vulnerabilities are found
    - name: Fail on critical vulnerabilities
      if: steps.vulnerability_scan.outputs.critical_found == '1'
      run: |
        Write-Host "üí• Build failed due to critical/high severity vulnerabilities!"
        Write-Host "Please review the security scan results and update vulnerable packages."
        exit 1

  epic-progress-check:
    name: Epic Progress Tracking
    runs-on: ubuntu-latest
    # Only run for epic feature branches and after build completes
    needs: [build-and-test]
    if: always() && startsWith(github.ref, 'refs/heads/feature/epic')

    steps:
    - name: Extract Epic Number
      id: epic
      run: |
        BRANCH_NAME="${{ github.ref_name }}"
        EPIC_NUM=$(echo $BRANCH_NAME | grep -o 'epic[0-9]\+' | grep -o '[0-9]\+')
        echo "number=$EPIC_NUM" >> $GITHUB_OUTPUT
        echo "Extracted epic number: $EPIC_NUM"

    - name: Post Epic Progress Update
      uses: actions/github-script@v7
      with:
        script: |
          const epicNumber = '${{ steps.epic.outputs.number }}';
          
          try {
            // Find Epic issue by label and title pattern
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'üèóÔ∏è epic',
              state: 'open'
            });
            
            const epicIssue = issues.data.find(issue => 
              issue.title.includes(`Epic ${epicNumber}`) || 
              issue.title.includes(`Epic #${epicNumber}`) ||
              issue.title.toLowerCase().includes(`epic ${epicNumber}`)
            );
            
            if (epicIssue) {
              const buildResult = '${{ needs.build-and-test.result }}';
              const buildStatus = buildResult === 'success' ? '‚úÖ' : '‚ùå';
              const statusText = buildResult === 'success' ? 'passing' : 'failing';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicIssue.number,
                body: `üöÄ **CI Build Update for Epic ${epicNumber}**\n\n` +
                      `${buildStatus} **Status**: Build and tests ${statusText}\n` +
                      `üìù **Branch**: \`${{ github.ref_name }}\`\n` +
                      `üîó **Commit**: ${{ github.sha }}\n` +
                      `üìä **Platform**: ${{ env.TARGET_PLATFORM }} ${{ env.BUILD_CONFIGURATION }}\n\n` +
                      `[View full CI run ‚Üí](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
              
              console.log(`‚úÖ Updated Epic #${epicIssue.number}`);
            } else {
              console.log(`‚ö†Ô∏è No Epic issue found for Epic ${epicNumber}`);
            }
          } catch (error) {
            console.log(`‚ùå Error updating Epic: ${error.message}`);
          }

  validate-epic-completion:
    name: Epic Completion Validation
    runs-on: ubuntu-latest
    # Only run for PRs targeting v2-dev from epic branches
    if: github.event_name == 'pull_request' && github.base_ref == 'v2-dev' && startsWith(github.head_ref, 'feature/epic')

    steps:
    - name: Validate Epic Completion Checklist
      uses: actions/github-script@v7
      with:
        script: |
          const pr = context.payload.pull_request;
          const body = pr.body || '';
          const headRef = pr.head.ref;
          
          console.log(`Validating Epic completion for PR #${pr.number}`);
          console.log(`Branch: ${headRef}`);
          
          // Extract epic number from branch name
          const epicMatch = headRef.match(/epic(\d+)/);
          const epicNumber = epicMatch ? epicMatch[1] : 'unknown';
          
          // Define required checklist items for Epic completion
          const requiredChecks = [
            'All acceptance criteria met',
            'Unit tests written and passing', 
            'Integration tests completed',
            'Code reviewed and approved',
            'Documentation updated',
            'Epic tracking issue updated'
          ];
          
          // Check which items are missing from the PR body
          const missingChecks = requiredChecks.filter(check => {
            const patterns = [
              `- [x] ${check}`,
              `- [X] ${check}`,
              `* [x] ${check}`,
              `* [X] ${check}`
            ];
            return !patterns.some(pattern => body.includes(pattern));
          });
          
          // Generate validation results
          if (missingChecks.length > 0) {
            const warningMessage = `‚ö†Ô∏è **Epic ${epicNumber} Completion Checklist Validation**\n\n` +
              `This PR appears to be completing an Epic, but some required items are missing from the description:\n\n` +
              missingChecks.map(item => `- [ ] ${item}`).join('\n') + '\n\n' +
              `**Please ensure all Epic requirements are completed before merging.**\n\n` +
              `### How to fix this:\n` +
              `1. Edit this PR description\n` +
              `2. Add the missing checklist items\n` +
              `3. Mark completed items as \`- [x] Item description\`\n\n` +
              `### Required Epic completion checklist:\n` +
              requiredChecks.map(item => `- [ ] ${item}`).join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: warningMessage
            });
            
            console.log(`‚ùå Missing ${missingChecks.length} required items`);
            core.setFailed(`Epic completion validation failed: ${missingChecks.length} missing items`);
          } else {
            const successMessage = `‚úÖ **Epic ${epicNumber} Completion Validated**\n\n` +
              `All required Epic completion items are present in the PR description. ` +
              `The Epic appears ready for final review and merge!`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: successMessage
            });
            
            console.log(`‚úÖ All Epic completion requirements satisfied`);
          }

  notify-status:
    name: Notify Build Status
    runs-on: ubuntu-latest
    needs: [build-and-test]
    # Include security scan only if it ran (PR events)
    if: always()

    steps:
    - name: Determine overall status
      id: status
      run: |
        BUILD_STATUS="${{ needs.build-and-test.result }}"
        
        # Check if security scan ran and its status
        SECURITY_STATUS="skipped"
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          SECURITY_STATUS="${{ needs.security-scan.result || 'not_run' }}"
        fi
        
        echo "build_status=$BUILD_STATUS" >> $GITHUB_OUTPUT
        echo "security_status=$SECURITY_STATUS" >> $GITHUB_OUTPUT
        
        # Determine overall success
        if [ "$BUILD_STATUS" = "success" ] && [ "$SECURITY_STATUS" != "failure" ]; then
          echo "overall_status=success" >> $GITHUB_OUTPUT
        else
          echo "overall_status=failure" >> $GITHUB_OUTPUT
        fi

    - name: Build Success Notification
      if: steps.status.outputs.overall_status == 'success'
      run: |
        echo "‚úÖ All checks passed successfully!"
        echo "üèóÔ∏è Build: ${{ steps.status.outputs.build_status }}"
        echo "üõ°Ô∏è Security: ${{ steps.status.outputs.security_status }}"
        echo "üéØ Target: ${{ env.TARGET_PLATFORM }} ${{ env.BUILD_CONFIGURATION }}"
        echo "üîß .NET: ${{ env.DOTNET_VERSION }}"

    - name: Build Failure Notification  
      if: steps.status.outputs.overall_status == 'failure'
      run: |
        echo "‚ùå One or more checks failed!"
        echo "üèóÔ∏è Build: ${{ steps.status.outputs.build_status }}"
        echo "üõ°Ô∏è Security: ${{ steps.status.outputs.security_status }}"
        echo "üìã Check the job logs for detailed error information"
        exit 1

    - name: Update commit status
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const state = '${{ steps.status.outputs.overall_status }}' === 'success' ? 'success' : 'failure';
          const description = state === 'success' ? 
            'All builds and tests passed' : 
            'Build or tests failed';
            
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: context.sha,
            state: state,
            description: description,
            context: 'ci/build-and-test'
          });